#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This code is licensed under the GNU General Public License 3.0 (GPL 3.0)
by Dr. med. Hinrich Winther, Machine Learning Work Group, 
Institute of Diagnostic and Interventional Radiology,
Hannover Medical School.
"""

__author__ = "Hinrich Winther"
__copyright__ = "Copyright 2025, Hannover Medical School"
__license__ = "GPL 3.0"


from os import path
import random
import nibabel as nib
import numpy as np
import pydicom
from pydicom.dataset import Dataset, FileDataset
from pydicom.uid import RLELossless
import datetime


def nifti_3d_to_dicom(
        nifti_img: nib.Nifti1Image,
        output_folder: str,
        PatientName: str = "Anonymous",
        PatientID: str = "".join(random.choices("0123456789", k=8)),
        Modality: str = "CT",
        StudyDescription: str = "",
        SeriesDescription: str = "",
        SeriesNumber: int = 1,
        StudyInstanceUID: str = pydicom.uid.generate_uid(),
        SeriesInstanceUID: str = pydicom.uid.generate_uid(),
        CreationDateTime: datetime.datetime = datetime.datetime.now()
        ) -> None:
    """
    Convert a 3D NIfTI image into a series of DICOM slices and save them to disk.

    Parameters
    ----------
    nifti_img : nib.Nifti1Image
        A loaded NIfTI image object from which pixel data and affine transformations
        will be extracted.
    output_folder : str
        The directory where resulting DICOM files will be saved.
    PatientName : str, optional
        Patient's name in the DICOM header (default is 'Anonymous').
    PatientID : str, optional
        Patient ID for the DICOM header, randomly generated by default.
    Modality : str, optional
        Modality tag for the DICOM header (default is 'CT').
    StudyDescription : str, optional
        Description of the DICOM study (default is '').
    SeriesDescription : str, optional
        Description of the DICOM series (default is '').
    SeriesNumber : int, optional
        Numerical identifier for the DICOM series (default is 1).
    StudyInstanceUID : str, optional
        Unique identifier for the DICOM study (default is a newly generated UID).
    SeriesInstanceUID : str, optional
        Unique identifier for the DICOM series (default is a newly generated UID).
    CreationDateTime : datetime.datetime, optional
        Date and time used for ContentDate and ContentTime in the DICOM metadata
        (default is the current date/time).

    Returns
    -------
    None
        This function does not return a value. DICOM slices are written to disk in
        the specified output_folder.
    """

    # Load the NIfTI file
    affine = nifti_img.affine
    nifti_data = nifti_img.get_fdata()

    # Flip from RAS to LPS for the 3x3 rotation and the translation vector
    flip = np.diag([-1, -1, 1])
    R_lps = flip @ affine[:3, :3]
    t_lps = flip @ affine[:3, 3]

    # Extract row and column direction vectors (normalize them â†’ direction cosines)
    row_dir = R_lps[:, 0] / np.linalg.norm(R_lps[:, 0])
    col_dir = R_lps[:, 1] / np.linalg.norm(R_lps[:, 1])
    iop = np.concatenate([row_dir, col_dir])  # 6-element array

    # calculate pixel spacing
    col_vec = flip @ affine[:3, 0]
    row_vec = flip @ affine[:3, 1]
    col_spacing = np.linalg.norm(col_vec)
    row_spacing = np.linalg.norm(row_vec)
    pixel_spacing = np.array([row_spacing, col_spacing]).tolist()

    # Compute slice direction and position for the specified slice
    slice_dir = R_lps[:, 2]
    slice_thickness = np.sqrt(np.sum(slice_dir**2))

    # Normalize the data
    data_min_val, data_max_val = nifti_data.min(), nifti_data.max()
    RescaleSlope = (data_max_val - data_min_val) / 65535
    RescaleIntercept = data_min_val
    nifti_data = np.interp(nifti_data, (data_min_val, data_max_val), (0, 65535)).astype(np.uint16)
    
    # Generate DICOM slices
    FrameOfReferenceUID = pydicom.uid.generate_uid()
    num_slices = nifti_data.shape[2]
    for i in range(num_slices):
        slice_data = nifti_data[:, :, i].T

        # Create a new DICOM file
        file_meta = pydicom.dataset.FileMetaDataset()
        file_meta.MediaStorageSOPClassUID = pydicom.uid.SecondaryCaptureImageStorage
        file_meta.MediaStorageSOPInstanceUID = pydicom.uid.generate_uid()
        file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian

        # Create the main dataset
        ds = FileDataset(None, {}, file_meta=file_meta, preamble=b"\0" * 128)

        # Set creation date/time
        ds.ContentDate = CreationDateTime.strftime('%Y%m%d')
        ds.ContentTime = CreationDateTime.strftime('%H%M%S.%f')

        # Set patient and study data (customize these)
        ds.PatientName = PatientName
        ds.PatientID = PatientID
        ds.StudyInstanceUID = StudyInstanceUID
        ds.SeriesInstanceUID = SeriesInstanceUID
        ds.SOPInstanceUID = file_meta.MediaStorageSOPInstanceUID
        ds.SOPClassUID = pydicom.uid.SecondaryCaptureImageStorage
        ds.Modality = Modality
        ds.SeriesNumber = str(SeriesNumber)
        ds.InstanceNumber = str(i + 1)
        ds.SeriesDescription = SeriesDescription
        ds.StudyDescription = StudyDescription

        # Set pixel data
        ds.Rows, ds.Columns = slice_data.shape
        ds.PhotometricInterpretation = "MONOCHROME2"
        ds.SamplesPerPixel = 1
        ds.BitsAllocated = 16
        ds.BitsStored = 16
        ds.HighBit = 15
        ds.PixelRepresentation = 0
        ds.RescaleSlope = RescaleSlope
        ds.RescaleIntercept = RescaleIntercept
        ds.PixelData = slice_data.tobytes()

        # Set pixel spacing
        ds.PixelSpacing = pixel_spacing
        ds.SliceThickness = slice_thickness
        ds.ImagePositionPatient = (t_lps + slice_dir * i).tolist()
        ds.ImageOrientationPatient = iop.tolist()
        ds.FrameOfReferenceUID = FrameOfReferenceUID

        # Save the DICOM file
        ds.compress(RLELossless)
        ds.save_as(f"{output_folder}/{ds.SOPInstanceUID}.dcm", enforce_file_format=True)